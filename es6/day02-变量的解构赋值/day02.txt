变量的解构赋值
1.	数组的解构赋值
	1.1	基本用法：
		ES6 允许写成下面这样：
		let [a, b, c] = [1, 2, 3];
		本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
		如果解构不成功，变量的值就等于undefined。
		另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。		

		// 报错
		let [foo] = 1;
		let [foo] = false;
		let [foo] = NaN;
		let [foo] = undefined;
		let [foo] = null;
		let [foo] = {};
		上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
		对于 Set 结构，也可以使用数组的解构赋值。
	1.2	默认值：
		解构赋值允许指定默认值。
		let [foo = true] = [];
		foo // 默认为true

		let [x, y = 'b'] = ['a']; // x='a', y='b'
		let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
		注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
		如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
2.	对象的解构赋值
	对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
	let { foo, bar } = { foo: "aaa", bar: "bbb" };
	foo // "aaa"
	bar // "bbb"
	对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
	let { foo: baz } = { foo: "aaa", bar: "bbb" };
	baz // "aaa"
	foo // error: foo is not defined
	上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
	对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。
3.	字符串的解构赋值
	字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
	let {length : len} = 'hello';
	len // 5
4.	数值和布尔值的解构赋值
5.	函数参数的解构赋值
6.	圆括号问题：只要有可能导致解构的歧义，就不得使用圆括号。
7.	用途：
	7.1	交换变量的值
	7.2	从函数返回多个值
	7.3	函数参数的定义
	7.4	提取JSON数据
		let jsonData = {
		  	id: 42,
		  	status: "OK",
		  	data: [867, 5309]
		};

		let {id, status, data: number} = jsonData;

		console.log(id, status, number);
	7.5	函数参数的默认值
	7.6	遍历Map结构
		任何部署了 Iterator 接口的对象，都可以用for...of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。
	7.7	输入模块的指定方法


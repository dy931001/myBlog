1.  let 
    let声明的变量只在它所在的代码块有效。
    for循环：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
    不存在变量提升：所声明的变量一定要在声明后才能使用
    暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

2.  块级作用域
    为什么需要块级作用域？
        答：ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
            第一种场景，内层变量可能会覆盖外层变量。
            第二种场景，用来计数的循环变量泄露为全局变量。
    ES6的块级作用域
        块级作用域的出现使得之前的立即执行函数不再必要。
        函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。
            ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
            ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
3.  const命令
    const声明一个只读的常量。一旦声明，常量的值就不能改变。
    const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
    如块级作用域，暂时性死区，不可重复声明等特性与let一致。
    本质：
        const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，
        因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），
        至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
    ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。
4.  顶层对象的属性
    顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。
    ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，
    不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
        var a = 1;
        // 如果在 Node 的 REPL 环境，可以写成 global.a
        // 或者采用通用方法，写成 this.a
        window.a // 1

        let b = 1;
        window.b // undefined
5.  global对象
    各个环境实现不统一
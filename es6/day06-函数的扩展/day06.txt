函数的扩展

1.	函数参数的默认值
	1.1	ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
			function log(x, y = 'World') {
			  console.log(x, y);
			}
			优势：代码简洁；阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。
			参数变量是默认声明的，所以不能用let或const再次声明。
	1.2.与解构赋值默认值结合使用
			参数默认值可以与解构赋值的默认值，结合起来使用。
			function foo({x, y = 5} = {}) {
			  console.log(x, y);
			}

			foo() // undefined 5
			上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。
	1.3.参数默认值的位置
		通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的
		上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。
	1.4.函数的length属性
		指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
		length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。
	1.5.作用域
		一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。
2.	rest参数
	ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
	arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。
	函数的length属性，不包括 rest 参数。
3.	严格模式
	从 ES5 开始，函数内部可以设定为严格模式。
	ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
4.	name属性
	函数的name属性，返回该函数的函数名。
	匿名函数赋值给一个变量，es5返回空字符串，es6返回变量名。
	具名函数赋值给一个变量，es5和es6都返回这个具名函数的本来的名字。
	Function构造函数返回的函数实例，name属性的值为anonymous。
	bind返回的函数，name属性值会加上bound前缀。
5.	箭头函数
	let f = v => v;
	由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
	注意使用点：
		1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
		2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
		3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
		4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
6.	双冒号运算符
	函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
7. 	尾调用优化
	尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。
	如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
8.	尾递归
	函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
	“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。
9.	递归函数的改写
	柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
10.	严格模式
	ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。
1.浏览器的加载
	
	1.1传统方法
		如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。

		<script src="path/to/myModule.js" defer></script>
		<script src="path/to/myModule.js" async></script>

		defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。

	1.2加载规则
		浏览器加载 ES6 模块，也使用<script>标签，但是要加入type="module"属性。
		<script type="module" src="./foo.js"></script>

		一旦使用了async属性，<script type="module">就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。

		对于外部的模块脚本，有几点需要注意：
			代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
			模块脚本自动采用严格模式，不管有没有声明use strict。
			模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。
			模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。
			同一个模块如果加载多次，将只执行一次。

2.ES6 模块与 CommonJS 模块的差异

	CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
	CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

	第二个差异是因为CommonJS加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
